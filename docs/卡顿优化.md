# 卡顿优化

### 背景
#### CPU 和 GPU
CPU: 对象的创建和销毁，对象属性的调整，布局计算，文本的计算排版，图片的格式转换和解码，图像的绘制(core graphics)
GPU: 纹理的渲染

#### 成像原理
1. CPU计算视图frame，图片解码，绘制纹理交给GPU
2. GPU纹理混合，顶点变换，渲染到帧缓冲区
3. 时钟信号：垂直同步信号V-Sync / 水平同步信号H-Sync。
4. 视频控制器按照一定的刷新频率从缓冲区获取新的图像用于显示

![成像原理](https://github.com/HHeFFFeng/Interview-iOS/blob/main/docs/media/16456699627636.jpg)

#### 相关概念
**离屏渲染**：非缓冲区(如 CPU 和 非GPU缓冲区)的渲染统称为离屏渲染</br>
**光栅化**：隐式创建一个位图，各种阴影遮罩等效果也会保存到位图中缓存起来，从而减少渲染的频度，把GPU的操作转到CPU上，生成位图缓存，直接读取调用。（注：对于经常变动的内容，不要开启光栅化，防止性能浪费，如Cell的复用）</br>
**GPU缓存区渲染优势**：为图像显示做了高度优化，速度较快</br>

### 卡顿原因
按照60FPS的刷帧率，每隔16ms就会有一次VSync信号，如果下个VSync信号来的时候，新的图像还没渲染到缓冲区就会造成卡顿

### 解决办法
尽可能减少CPU、GPU资源消耗

#### CPU途径
1. 对象创建：对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗CPU资源。尽量采取轻量级对象，尽量放到后台线程处理，尽量推迟对象的创建时间。（如UIView / CALayer）
2. 对象调整：frame、bounds、transform及视图层次等属性调整很耗费CPU资源。尽量减少不必要属性的修改，尽量避免调整视图层次、添加和移除视图。
3. 布局计算：随着视图数量的增长，Autolayout带来的CPU消耗会呈指数级增长，所以尽量提前算好布局，在需要时一次性调整好对应属性。
4. 文本渲染：屏幕上能看到的所有文本内容控件，包括UIWebView，在底层都是通过CoreText排版、绘制为位图显示的。常见的文本控件，其排版与绘制都是在主线程进行的，显示大量文本是，CPU压力很大。对此解决方案唯一就是自定义文本控件，用CoreText对文本异步绘制。（很麻烦，开发成本高）
5. 图片解码：当用UIImage或CGImageSource创建图片时，图片数据并不会立刻解码。图片设置到UIImageView或CALayer.contents中去，并且CALayer被提交到GPU前，CGImage中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。SD_WebImage处理方式：在后台线程先把图片绘制到CGBitmapContext中，然后从Bitmap直接创建图片。
6. 图像绘制：图像的绘制通常是指用那些以CG开头的方法把图像绘制到画布中，然后从画布创建图片并显示的一个过程。CoreGraphics方法是线程安全的，可以异步绘制，主线程回调。

#### GPU途径
1. 尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示
2. GPU能处理的最大纹理尺寸是4096x4096，一旦超过这个尺寸，就会占用CPU资源进行处理，所以纹理尽量不要超过这个尺寸
3. 尽量减少视图数量和层次
4. 减少透明的视图（alpha<1），不透明的就设置opaque为YES
5. 尽量避免出现离屏渲染
 
### Instruments 卡顿监测
TODO: 待补充
